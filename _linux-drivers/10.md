---
title: 10. The input subsystem 
---
# Input subsystem overview

The mentioned files, `input.c`, `input-polldev.c`, and `evdev.c`, are part of the Linux kernel's input subsystem and are used for handling input devices and events. Let's briefly explain each of them with examples:

1. **`input.c`:**
   - `input.c` is a core file of the input subsystem that provides the basic infrastructure for input devices and event handling.
   - It defines functions and data structures for registering input devices, managing event handlers, and delivering input events to user space.
   - Example: In `input.c`, you might find functions like `input_register_device()` to register an input device and `input_event()` to send input events.

2. **`input-polldev.c`:**
   - `input-polldev.c` is a file that contains code for input devices that use a polling mechanism to report events.
   - Polling devices are those that are not interrupt-driven but are periodically polled by the kernel to check for changes.
   - Example: A simple example of a polling device is a PS/2 mouse that periodically sends its state, and the kernel needs to poll it to capture the state changes.

3. **`evdev.c`:**
   - `evdev.c` stands for "event device" and is a subsystem within the input subsystem.
   - It is responsible for creating event interfaces (`/dev/input/eventX`) that user space applications can use to read input events.
   - Example: When you interact with a USB keyboard or mouse, the input events generated by these devices are typically made available to user space through the `/dev/input/eventX` interfaces, which are managed by `evdev.c`.

Here's a simple example of how these files work together:

Let's say you have a USB keyboard (`usbkbd.c`) that you want to integrate with the Linux input subsystem.

1. The USB keyboard driver (`usbkbd.c`) registers the keyboard as an input device using functions from `input.c`. It provides event data such as key presses and releases to the input subsystem.

2. If the keyboard is a polling device, the code for handling its polling behavior might be in a file like `input-polldev.c`. It ensures that the input subsystem periodically checks the keyboard for input events.

3. The `evdev.c` subsystem is responsible for creating the `/dev/input/eventX` interface corresponding to the keyboard. User space applications can open and read from this interface to receive input events from the keyboard.

Overall, these files and components work together to manage input devices and events in the Linux kernel, enabling user interaction with the system through various input devices like keyboards, mice, and touchpads.

## `struct input_dev`: 

The `struct input_dev` is a fundamental data structure in the Linux kernel's input subsystem. It represents an input device and provides a way to configure and manage the device's properties, such as its capabilities and event handling. The `input_dev` structure is used by input device drivers to interface with the input subsystem. Below, I'll explain its components with an example and mention the header file where it's typically defined.

**Header File:**
The `struct input_dev` is typically defined in the Linux kernel's `input.h` header file. This file contains declarations related to the input subsystem, including data structures and function prototypes.

Here's a simplified example of how a `struct input_dev` can be used in an input device driver:

```c
#include <linux/input.h>

static struct input_dev *my_input_device;

static int my_input_device_init(void) {
    int error;

    // Allocate memory for the input device
    my_input_device = input_allocate_device();
    if (!my_input_device) {
        printk(KERN_ERR "Failed to allocate input device\n");
        return -ENOMEM;
    }

    // Set the input device properties
    my_input_device->name = "My Custom Input Device";
    my_input_device->phys = "input0";
    my_input_device->id.bustype = BUS_USB;
    my_input_device->id.vendor = 0x1234;
    my_input_device->id.product = 0xabcd;
    my_input_device->id.version = 0x0100;

    // Set the input device capabilities
    set_bit(EV_KEY, my_input_device->evbit);  // Enable key events
    set_bit(KEY_A, my_input_device->keybit);  // Enable the 'A' key

    // Register the input device
    error = input_register_device(my_input_device);
    if (error) {
        printk(KERN_ERR "Failed to register input device\n");
        input_free_device(my_input_device);
        return error;
    }

    return 0;
}

static void my_input_device_exit(void) {
    // Unregister and free the input device
    input_unregister_device(my_input_device);
    input_free_device(my_input_device);
}

module_init(my_input_device_init);
module_exit(my_input_device_exit);
```

In this example:

- We include the `<linux/input.h>` header to access the `struct input_dev` and related functions.

- We allocate memory for an input device using `input_allocate_device()`.

- We set various properties of the input device, including its name, physical location, and identification information.

- We specify the input device's capabilities, such as key events, by using `set_bit` to enable the event types and codes.

- Finally, we register the input device using `input_register_device()` and provide an initialization and exit function for the kernel module.

This example demonstrates how to create and configure an input device using `struct input_dev`. It's a simplified illustration, and real-world input device drivers may have more complex logic depending on the type of device and the desired functionality.





## `struct input_handler`: 


The `struct input_handler` is another critical data structure in the Linux kernel's input subsystem. It represents an input event handler, which is responsible for processing input events generated by input devices and dispatching them to user space or other parts of the kernel. Below, I'll explain `struct input_handler` along with a basic example and mention the header file where it's typically defined.

**Header File:**
The `struct input_handler` is defined in the Linux kernel's `input.h` header file, which contains declarations related to the input subsystem, including data structures and function prototypes.

Here's a simplified example of how a `struct input_handler` can be used in an input handler module:

```c
#include <linux/input.h>

static int my_input_event(struct input_dev *dev, unsigned int type, unsigned int code, int value) {
    // Handle input events here
    printk(KERN_INFO "Input event: type=%u, code=%u, value=%d\n", type, code, value);
    return 0;
}

static struct input_handler my_input_handler = {
    .event = my_input_event,
    .name = "My Input Event Handler",
};

static int __init my_input_handler_init(void) {
    int error;

    // Register the input handler
    error = input_register_handler(&my_input_handler);
    if (error) {
        printk(KERN_ERR "Failed to register input handler\n");
        return error;
    }

    return 0;
}

static void __exit my_input_handler_exit(void) {
    // Unregister the input handler
    input_unregister_handler(&my_input_handler);
}

module_init(my_input_handler_init);
module_exit(my_input_handler_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Sample Input Event Handler");
```

In this example:

- We include the `<linux/input.h>` header to access `struct input_handler` and related functions.

- We define a callback function `my_input_event` that will be invoked whenever an input event is received. This function processes the input event's type, code, and value.

- We initialize a `struct input_handler` named `my_input_handler` and specify our `my_input_event` function as the event handler.

- In the `my_input_handler_init` function, we register our input handler using `input_register_handler()`.

- In the `my_input_handler_exit` function, we unregister the input handler using `input_unregister_handler()`.

- We specify licensing and module information using module attributes.

This example demonstrates how to create an input event handler using `struct input_handler`. The input handler is registered with the input subsystem and processes input events generated by input devices. The actual event handling logic in `my_input_event` can be customized to suit the specific requirements of your input event handler module.


# Input subsystem API 1/3
## `struct input_dev`

The `struct input_dev` is a fundamental data structure in the Linux kernel's input subsystem. It represents an input device and provides a way to configure and manage the device's properties, such as its capabilities and event handling. Let's delve into `struct input_dev` with an example:

**Header File:**
The `struct input_dev` is typically defined in the Linux kernel's `input.h` header file, which contains declarations related to the input subsystem, including data structures and function prototypes.

**Example: Creating and Configuring an Input Device**

Below is a simplified example of how to create and configure an input device using `struct input_dev`:

```c
#include <linux/input.h>

static struct input_dev *my_input_device;

static int __init my_input_device_init(void) {
    int error;

    // Allocate memory for the input device
    my_input_device = input_allocate_device();
    if (!my_input_device) {
        printk(KERN_ERR "Failed to allocate input device\n");
        return -ENOMEM;
    }

    // Set the input device properties
    my_input_device->name = "My Custom Input Device";
    my_input_device->phys = "input0";
    my_input_device->id.bustype = BUS_USB;
    my_input_device->id.vendor = 0x1234;
    my_input_device->id.product = 0xabcd;
    my_input_device->id.version = 0x0100;

    // Set the input device capabilities
    set_bit(EV_KEY, my_input_device->evbit);  // Enable key events
    set_bit(KEY_A, my_input_device->keybit);  // Enable the 'A' key

    // Register the input device
    error = input_register_device(my_input_device);
    if (error) {
        printk(KERN_ERR "Failed to register input device\n");
        input_free_device(my_input_device);
        return error;
    }

    return 0;
}

static void __exit my_input_device_exit(void) {
    // Unregister and free the input device
    input_unregister_device(my_input_device);
    input_free_device(my_input_device);
}

module_init(my_input_device_init);
module_exit(my_input_device_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Your Name");
MODULE_DESCRIPTION("Sample Input Device");
```

In this example:

- We include the `<linux/input.h>` header to access the `struct input_dev` and related functions.

- In the `my_input_device_init` function, we allocate memory for an input device using `input_allocate_device()`.

- We set various properties of the input device, including its name, physical location, and identification information.

- We specify the input device's capabilities, such as key events, by using `set_bit` to enable the event types and codes.

- Finally, we register the input device using `input_register_device()` and provide an initialization and exit function for the kernel module.

This example demonstrates how to create and configure an input device using `struct input_dev`. It's a simplified illustration, and real-world input device drivers may have more complex logic depending on the type of device and the desired functionality.


##More 
The `struct input_dev` structure represents an input device in the Linux kernel's input subsystem. It contains various fields that describe the device's properties, capabilities, and event handling functions. Here is an overview of some important fields in `struct input_dev`:

- `const char *name`: A string that provides a human-readable name for the input device.

- `struct input_id id`: A structure containing identification information for the input device, such as its bus type, vendor ID, product ID, and version.

- `unsigned long evbit[BITS_TO_LONGS(EV_CNT)]`: A bitmap that indicates the types of input events supported by the device. Each bit corresponds to a specific event type (e.g., EV_KEY, EV_ABS, EV_REL).

- `unsigned long keybit[BITS_TO_LONGS(KEY_CNT)]`: A bitmap that specifies the key codes supported by the device. Each bit corresponds to a specific key code (e.g., KEY_A, KEY_B).

- `int (*getkeycode)(struct input_dev *dev, struct input_keymap_entry *ke)`: A function pointer that allows the device driver to provide custom key code mappings.

- `int (*open)(struct input_dev *dev)`: A function pointer that is called when the input device is opened. It can be used for initialization or resource allocation.

- `int (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value)`: A function pointer that is called to report input events generated by the device. It receives parameters specifying the event type, code, and value.

Initializing `struct input_dev` typically involves the following steps:

1. Allocation: You allocate memory for the input device structure, either using `input_allocate_device()` or `devm_input_allocate_device()`.

2. Configuration: You set various properties and capabilities of the input device, such as its name, ID, supported event types, and key codes.

3. Event Handling: You may define event handling functions, such as `open` and `event`, to customize the behavior of the input device.

4. Registration: You register the input device using `input_register_device()`. Once registered, the device can generate and report input events.

5. Cleanup: When the input device is no longer needed, you should unregister and free it using `input_unregister_device()` and `input_free_device()`.

The choice between `input_allocate_device()` and `devm_input_allocate_device()` depends on whether you want to manually manage the device's lifetime (allocation and deallocation) or have it automatically managed as a managed resource. `devm_input_allocate_device()` is suitable for managed resources, as it will be automatically freed when the associated device is unbound from the driver.

The `struct input_dev` structure is essential for creating input device drivers in Linux and allows you to interact with a wide range of input devices, including keyboards, mice, touchscreens, and more.

# Input subsystem API 2/3

##  "EV_KEY" and "BTN_0"

In the context of the Linux kernel's input subsystem, "EV_KEY" and "BTN_0" refer to event types and key codes used to describe input events generated by input devices. Here's an explanation of each:

1. **EV_KEY (Event Type Key):**
   - `EV_KEY` is an event type used to categorize input events that represent key or button presses and releases.
   - It is one of several event types defined in the input subsystem and is used to distinguish keyboard key presses, mouse button clicks, and similar events.
   - When an input event has the event type `EV_KEY`, it typically means that the event represents a key or button interaction.

2. **BTN_0 (Button Code 0):**
   - `BTN_0` is a key code representing a specific button on an input device, such as a mouse or a game controller.
   - Key codes like `BTN_0` are used to uniquely identify individual buttons or keys on an input device.
   - In this case, "BTN_0" specifically represents the first button (usually the leftmost button) on the input device. Subsequent button codes like `BTN_1`, `BTN_2`, and so on are used for other buttons if they exist.

For example, if you have a mouse with three buttons, you would typically encounter key codes `BTN_0`, `BTN_1`, and `BTN_2` to represent the left, middle, and right buttons, respectively. These key codes are used to report mouse button presses and releases as input events with the event type `EV_KEY`.

In summary, `EV_KEY` is the event type that indicates key or button-related input events, and `BTN_0` is a specific key code representing the first button on an input device. These event types and key codes are part of the standard definitions in the Linux input subsystem and are used to categorize and identify input events from various input devices.


# Input subsystem API 3/3

## input_event


The `input_event` function is a fundamental function in the Linux kernel's input subsystem. It is used to generate and send input events to the input subsystem, which can then be processed by higher-level layers or user-space applications. The function takes several parameters that describe the input event:

- `struct input_dev *dev`: A pointer to the `struct input_dev` representing the input device that generated the event.

- `unsigned int type`: An unsigned integer that specifies the type of the input event. Common event types include `EV_KEY` for key press and release events, `EV_ABS` for absolute position events (e.g., touch coordinates), and `EV_REL` for relative motion events (e.g., mouse movement).

- `unsigned int code`: An unsigned integer that specifies the event code or key code associated with the input event. The event code uniquely identifies the specific key, button, or event being reported.

- `int value`: An integer that represents the value associated with the event. The interpretation of the value depends on the event type and code. For key events (`EV_KEY`), the value typically indicates whether the key was pressed (1), released (0), or repeated (2).

Here's an example of how to use the `input_event` function to generate and send a key press event for the 'A' key using a hypothetical input device:

```c
#include <linux/input.h>

// Assume 'my_input_dev' is a pointer to the input device

void send_key_press_event(struct input_dev *my_input_dev) {
    // Define the input event parameters
    unsigned int event_type = EV_KEY;  // Event type: Key press
    unsigned int event_code = KEY_A;   // Key code for the 'A' key
    int event_value = 1;               // Key press event (1)

    // Use input_event to generate and send the key press event
    input_event(my_input_dev, event_type, event_code, event_value);
    input_sync(my_input_dev);  // Notify input subsystem of the event
}
```

In this example:

1. We specify the event type (`EV_KEY`) to indicate that we are generating a key press event.

2. The event code (`KEY_A`) represents the 'A' key on the keyboard.

3. We set the event value to `1` to indicate a key press event (0 would indicate a key release, and 2 would indicate key repetition).

4. We use the `input_event` function to create the input event and send it to the input subsystem.

5. The `input_sync` function is called to notify the input subsystem that the event is complete and should be processed.

This example demonstrates how to use `input_event` to generate and send a key press event for a specific key. Input events can be generated by device drivers to simulate user input or report events from physical input devices like keyboards and mice to the Linux input subsystem.

## `input_sync`

The `input_sync` function is a part of the Linux kernel's input subsystem and is used to synchronize and finalize input events generated by an input device. It is called to indicate the completion of a sequence of input events and ensures that any pending events are processed by the input subsystem. Here's an explanation of how it works:

- `struct input_dev *dev`: A pointer to the `struct input_dev` representing the input device for which synchronization is required.

When an input device generates multiple input events as part of a single user action (e.g., a series of key presses or mouse movements), it is important to use `input_sync` to signal the end of the event sequence. This is necessary because some input handlers or event consumers may need to process events as a group or sequence rather than individually.

Here's an example of how to use `input_sync`:

```c
#include <linux/input.h>

// Assume 'my_input_dev' is a pointer to the input device

void generate_input_events(struct input_dev *my_input_dev) {
    // Generate multiple input events here
    input_event(my_input_dev, EV_KEY, KEY_A, 1); // Key press 'A'
    input_event(my_input_dev, EV_KEY, KEY_B, 1); // Key press 'B'
    input_event(my_input_dev, EV_KEY, KEY_A, 0); // Key release 'A'
    input_event(my_input_dev, EV_KEY, KEY_B, 0); // Key release 'B'

    // Use input_sync to synchronize and signal the end of the event sequence
    input_sync(my_input_dev);
}
```

In this example:

1. Multiple input events are generated for key presses and releases for keys 'A' and 'B' using `input_event`.

2. After generating all the events, the `input_sync` function is called to signal the end of the event sequence.

Using `input_sync` ensures that any consumers or event handlers in the input subsystem can process the events as a coherent sequence. This is especially important for user interfaces and applications that rely on consistent and synchronized input events.



##  `input_report_key()` and `input_report_abs()`


`input_report_key()` and `input_report_abs()` are functions in the Linux kernel's input subsystem used to report input events for keys and absolute input devices (such as touchscreens or joysticks) respectively. These functions are typically called by device drivers to generate input events. Here's an explanation of each:

1. **`input_report_key(struct input_dev *dev, unsigned int code, int value)`**:
   - This function is used to report key press and release events.
   - Parameters:
     - `dev`: A pointer to the `struct input_dev` representing the input device.
     - `code`: An unsigned integer representing the key code for the event. Each key on the keyboard has a unique key code.
     - `value`: An integer representing the event value. Typically, `1` is used for key press, `0` for key release, and `2` for key repeat.

   Example of reporting a key press event for the 'A' key:
   ```c
   input_report_key(input_dev, KEY_A, 1);  // Key 'A' press event
   ```

2. **`input_report_abs(struct input_dev *dev, unsigned int axis, int value)`**:
   - This function is used to report absolute input events for devices like touchscreens or joysticks.
   - Parameters:
     - `dev`: A pointer to the `struct input_dev` representing the input device.
     - `axis`: An unsigned integer representing the absolute axis (e.g., X or Y coordinate) for which the event is reported.
     - `value`: An integer representing the absolute value of the axis. This value typically corresponds to the position or state of the input device along the specified axis.

   Example of reporting an absolute touchscreen event:
   ```c
   input_report_abs(input_dev, ABS_X, x_position);  // Report X-coordinate
   input_report_abs(input_dev, ABS_Y, y_position);  // Report Y-coordinate
   ```

Both of these functions are used to generate and report input events to the input subsystem. Once these events are reported, they can be processed by the input subsystem, event handlers, and user-space applications that rely on input data.

It's important to note that these functions should be used in the context of a device driver for a specific input device, and they help ensure that user interactions with the device are accurately represented as input events in the Linux kernel.

# Example from drivers/hid/usbhid/usbmouse.c


The code snippet you provided appears to be an example of an interrupt service routine (ISR) for a USB mouse device in the Linux kernel. This ISR is responsible for handling USB mouse input data received from a USB interrupt transfer (as indicated by the `struct urb *urb` parameter). Let's break down what this code does:

1. **Initialization**:
   - `struct usb_mouse *mouse = urb->context;`: Extracts a pointer to a `struct usb_mouse` data structure from the `context` field of the USB Request Block (URB). This structure likely contains information about the USB mouse device.
   - `signed char *data = mouse->data;`: Extracts a pointer to a character array `data` from the `struct usb_mouse`. This array is expected to contain the raw input data from the USB mouse.
   - `struct input_dev *dev = mouse->dev;`: Retrieves a pointer to the `struct input_dev` representing the input device associated with the USB mouse.

2. **Input Event Reporting**:
   - The following lines use the `input_report_key` function to report key press or release events for various mouse buttons (e.g., left, right, middle, etc.). The events are generated based on the data received from the USB mouse:
     - `input_report_key(dev, BTN_LEFT, data[0] & 0x01);`: Reports the left button state.
     - `input_report_key(dev, BTN_RIGHT, data[0] & 0x02);`: Reports the right button state.
     - `input_report_key(dev, BTN_MIDDLE, data[0] & 0x04);`: Reports the middle button state.
     - `input_report_key(dev, BTN_SIDE, data[0] & 0x08);`: Reports additional side button state.
     - `input_report_key(dev, BTN_EXTRA, data[0] & 0x10);`: Reports an extra button state.

   - The following lines use the `input_report_rel` function to report relative motion events for the mouse pointer along the X, Y, and wheel axes:
     - `input_report_rel(dev, REL_X, data[1]);`: Reports relative motion along the X-axis.
     - `input_report_rel(dev, REL_Y, data[2]);`: Reports relative motion along the Y-axis.
     - `input_report_rel(dev, REL_WHEEL, data[3]);`: Reports wheel movement.

3. **Synchronization**:
   - `input_sync(dev);`: Signals the completion of the input event report sequence, ensuring that any pending input events are processed by the input subsystem.

Overall, this code is responsible for interpreting the raw USB mouse data and translating it into input events (key presses, button releases, mouse movements) that can be processed by the Linux input subsystem. These events can then be used by user-space applications to control the mouse pointer and respond to mouse button clicks and movements.


# Polling input devices

## `input_setup_polling()`

The `input_setup_polling()` function is used to set up and initialize the polling mechanism for an input device in the Linux kernel. Polling is a method used to regularly check for input events, such as button presses or mouse movements, from hardware devices. This function is commonly used in device drivers for input devices like keyboards, mice, and touchpads.

Here's an explanation of `input_setup_polling()` and an example of how it can be used:

**Function Signature**:
```c
void input_setup_polling(struct input_dev *dev,
                        irqreturn_t (*handler)(int, void *),
                        struct poll_table_struct *wait);
```

**Parameters**:
- `struct input_dev *dev`: A pointer to the input device structure that represents the hardware device. This structure holds information about the input device and is used to manage input events.
- `irqreturn_t (*handler)(int, void *)`: A pointer to an interrupt handler function. This function is called when an  periodic event  is happend. It processes the input events and notifies the input subsystem.
- `struct poll_table_struct *wait`: A pointer to a poll table structure. This structure is used to manage the polling process and is typically provided by the caller.

**Usage Example**:

Here's a simplified example of how `input_setup_polling()` might be used in a keyboard driver:

```c
#include <linux/input.h>

static irqreturn_t keyboard_interrupt(int irq, void *dev_id)
{
    // Handle keyboard interrupt, read input data, and generate events
    // Notify the input subsystem of events (key presses, releases, etc.)
    // ...

    // Return IRQ_HANDLED when the interrupt is handled successfully
    return IRQ_HANDLED;
}

static int keyboard_probe(struct platform_device *pdev)
{
    struct input_dev *input_dev;

    // Create and initialize an input device structure
    input_dev = input_allocate_device();
    if (!input_dev) {
        printk(KERN_ERR "Failed to allocate input device\n");
        return -ENOMEM;
    }

    // Initialize the input device's capabilities and attributes (e.g., name, type)
    input_dev->name = "My Keyboard";
    input_dev->phys = "input/keyboard0";
    input_dev->id.bustype = BUS_HOST;
    input_dev->id.vendor = 0x0001;
    input_dev->id.product = 0x0001;
    input_dev->id.version = 0x0100;
    input_set_capability(input_dev, EV_KEY, KEY_A);
    input_set_capability(input_dev, EV_KEY, KEY_B);
    // Add more capabilities as needed

    // Set up polling for the input device with the keyboard_interrupt handler
    input_setup_polling(input_dev, keyboard_interrupt, NULL);

    // Register the input device with the input subsystem
    if (input_register_device(input_dev)) {
        printk(KERN_ERR "Failed to register input device\n");
        input_free_device(input_dev);
        return -ENOMEM;
    }

    // Device setup and registration successful
    return 0;
}

static int keyboard_remove(struct platform_device *pdev)
{
    // Remove and unregister the input device
    struct input_dev *input_dev = platform_get_drvdata(pdev);
    input_unregister_device(input_dev);
    input_free_device(input_dev);
    return 0;
}

// Other initialization and driver registration code
```

In this example, when the `keyboard_probe` function is called during driver initialization, it sets up polling for the input device using `input_setup_polling()`. The `keyboard_interrupt` function serves as the interrupt handler that processes keyboard events and notifies the input subsystem.

Please note that this is a simplified example, and real-world input drivers may have more complex logic and support additional input event types.


##  `input_set_poll_interval()` 
`input_set_poll_interval()` is a function used in the Linux kernel's input subsystem to specify the desired polling interval for an input device. Polling interval refers to how frequently the input device is checked for events, such as button presses, mouse movements, or touch events. This function allows device drivers to control the rate at which the input device is polled for events.

Here's an explanation of `input_set_poll_interval()` along with an example of its usage:

**Function Signature**:
```c
void input_set_poll_interval(struct input_dev *dev, int poll_interval);
```

**Parameters**:
- `struct input_dev *dev`: A pointer to the input device structure that represents the hardware device for which you want to set the polling interval.
- `int poll_interval`: The desired polling interval in milliseconds. This parameter specifies how often the input device should be polled for events.

**Usage Example**:

Let's say you are developing a driver for a simple button input device, and you want to set the polling interval to 20 milliseconds. Here's how you can use `input_set_poll_interval()`:

```c
#include <linux/input.h>

static struct input_dev *button_dev;

static irqreturn_t button_interrupt(int irq, void *dev_id)
{
    // Handle button interrupt, read input data, and generate events
    // ...

    // Return IRQ_HANDLED when the interrupt is handled successfully
    return IRQ_HANDLED;
}

static int button_probe(struct platform_device *pdev)
{
    // Create and initialize an input device structure
    button_dev = input_allocate_device();
    if (!button_dev) {
        printk(KERN_ERR "Failed to allocate input device\n");
        return -ENOMEM;
    }

    // Initialize the input device's capabilities and attributes
    button_dev->name = "My Button Device";
    button_dev->phys = "input/button0";
    button_dev->id.bustype = BUS_HOST;
    button_dev->id.vendor = 0x0001;
    button_dev->id.product = 0x0002;
    button_dev->id.version = 0x0100;
    
    // Specify the desired polling interval (20 milliseconds)
    input_set_poll_interval(button_dev, 20);

    // Set up interrupt handling and register the input device
    // ...

    // Return 0 to indicate success
    return 0;
}

static int button_remove(struct platform_device *pdev)
{
    // Remove and unregister the input device
    input_unregister_device(button_dev);
    input_free_device(button_dev);
    return 0;
}

// Other initialization and driver registration code
```

In this example, `input_set_poll_interval(button_dev, 20)` sets the polling interval for the button input device to 20 milliseconds. This means that the input subsystem will check for button events every 20 milliseconds. Adjusting the polling interval allows you to control the responsiveness and efficiency of the input device.

Keep in mind that the actual polling rate may be subject to system constraints and may not be exact. However, setting an appropriate polling interval ensures that the input device is checked at a reasonable frequency for most applications.

# evdev user space interface


The event interface in Linux is a mechanism for handling and reporting input events generated by various input devices, such as keyboards, mice, touchscreens, and joysticks. This interface allows applications and the system to receive and respond to user input events in a standardized way.

Here are key points and components of the event interface in Linux:

1. **Input Events**: Input events represent actions or changes in state produced by input devices. These events can include key presses, key releases, mouse movements, button clicks, touch gestures, and more. Each event is characterized by specific attributes like event type, event code, and event value.

2. **Event Types**: Events are categorized into different types, such as EV_KEY (key events), EV_REL (relative events, like mouse movement), EV_ABS (absolute events, like touchscreen coordinates), and others. Event types help classify the nature of the event.

3. **Event Codes**: Event codes provide additional information about the event within its category. For example, for EV_KEY events, event codes represent specific keys or buttons.

4. **Event Values**: Event values indicate the state or value associated with the event. For EV_KEY events, values can be 0 (release) or 1 (press). For EV_REL events, values represent the amount of movement.

5. **Input Devices**: Input devices are represented by the `struct input_dev` structure. Each input device is associated with a specific input driver and generates input events. The structure contains information about the device's capabilities, attributes, and handlers.

6. **Handlers**: Handlers are responsible for translating input from hardware-specific format into input events and submitting them to the input core. Input handlers are device-specific and can include keyboard handlers, mouse handlers, touchscreen handlers, etc.

7. **Input Core**: The input core is a part of the Linux kernel responsible for managing input devices and handling input events. It maintains a list of input devices, dispatches events to the appropriate handlers, and provides a common interface for user-space applications to access input events.

8. **Event File**: Input events can be read from event files typically located in the `/dev/input/` directory. These event files, such as `/dev/input/event0`, provide a way for user-space applications to access input events using standard I/O operations.

Here's a simplified example of how an input event might be generated and processed:

```c
#include <linux/input.h>

// Simulate a key press event
void simulate_keypress(struct input_dev *dev, int key_code) {
    input_event(dev, EV_KEY, key_code, 1);  // Key press (value = 1)
    input_sync(dev);  // Synchronize events
    input_event(dev, EV_KEY, key_code, 0);  // Key release (value = 0)
    input_sync(dev);  // Synchronize events
}

// User-space application reads and processes input events
int main() {
    int fd = open("/dev/input/event0", O_RDONLY);
    struct input_event ev;

    while (1) {
        read(fd, &ev, sizeof(struct input_event));

        if (ev.type == EV_KEY) {
            if (ev.code == KEY_A && ev.value == 1) {
                printf("Key A pressed\n");
            } else if (ev.code == KEY_A && ev.value == 0) {
                printf("Key A released\n");
            }
        }
    }

    close(fd);
    return 0;
}
```

In this example, a simulated key press event is generated using `input_event`, and a user-space application reads and processes input events from an event file.

The Linux input subsystem provides a standardized way for applications and the system to interact with input devices, making it easier to develop input-related software and handle user interactions across different hardware.



